<!DOCTYPE html>

<html lang="en">
    <head>
        <link href="styles/fonts.css" rel="stylesheet">
        <link href="styles/main.css" rel="stylesheet">
        <link rel="apple-touch-icon" sizes="180x180" href="images/apple-touch-icon.png">
        <link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png">
        <link rel="manifest" href="site.webmanifest">
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="This article explains three problems with numbers in programming: integer truncation, floating-point imprecision, and integer overflow.">
        <title>Three Problems With Programming</title>
    </head>
    <body>
        <article>
            <aside>
                <nav>
                    <header>Table of Contents</header>
                    <ul>
                        <li><a href="#top">Top</a></li>
                        <li><a href="#truncation">Integer Truncation</a></li>
                        <li><a href="#imprecision">Floating-point Imprecision</a></li>
                        <li><a href="#overflow">Integer Overflow</a></li>
                        <li><a href="#resources">Resources</a></li>
                    </ul>
                </nav>
            </aside>
            <div id="content">
                <header id="top">
                    <h1>Three Problems with Programming</h1>
                    <hr>
                </header>
                <main>
                    <p>There are many problems with programming, but we will focus on numbers. The three we will look at are</p>
                    <ol>
                        <li>Integer truncation</li>
                        <li>Floating-point imprecision</li>
                        <li>Integer overflow</li>
                    </ol>
                    <p>These all have to do with numbers not behaving the way they are supposed to be. Integer truncation is an
                    easy problem to fix, but floating-point imprecision and integer overflow are still problems today, and were back then.
                    For example, the Boeing 787 had to be reset at every 249 days, otherwise its clock would overflow.</p>
                    <section id="truncation">
                        <header>
                            <h2>Integer Truncation</h2>
                        </header>
                        <p>Let's say you were making a division quiz to test on your students in C, who are working on division with decimals.
                        You decide to start relatively easy, with 5 / 2. Your code might look something like this. (Let's say you implemented <code>get_float
                        </code>or used a library).</p>
<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    float answer = get_float("Q1: 5 / 2  ");
    if (answer == 5 / 2)
    {
        printf("Correct!\n");
    }
    else
    {
        printf("Incorrect!\n");
    }
    return 0;
}</code></pre>
                        <p>Let's give this a test to see if it works so far.</p>
<pre><code>$ cc quiz.c -o quiz
$ ./quiz
Q1: 5 / 2  2.5
Incorrect!
$</code></pre>

                        <p>How could it be incorrect? Let's figure out why. Add a trusty <code>printf</code> statement of the answer:</p>
<pre><code>printf("%f\n", answer);</code></pre>
<pre><code>$ cc quiz.c -o quiz
$ ./quiz
Q1: 5 / 2  2.5
2.500000
Incorrect!
</code></pre>
                        <p>Well, it worked, so I guess the 5 / 2 is incorrect? Surely the computer can't mess up like that?
                        All right, let's find out:</p>
<pre><code>printf("%f\n", 5 / 2);</code></pre>
<pre><code>$ cc quiz.c -o quiz
    quiz.c:8:20: warning: format specifies type 'double' but the argument has type 'int' [-Wformat]
        8 |     printf("%f\n", 5 / 2);
        |             ~~     ^~~~~
        |             %d
    $</code></pre>
                        <p>That compiler just gave us a warning! It might look a little different depending on the C compiler you use,
                        but it says that 5 / 2 is an <code>int</code>! That is because of how C works with operations.
                        Whenever you perform an operation, if both are <code>int</code>s, then the result is an <code>int</code>.
                        If the expression's result is 2.5, but it is an <code>int</code>, it just straight up cuts that decimal part out.
                        Sure enough, if you type in 2 with our quiz program, it says "Correct!". So how can we fix this?</p>
                        <p>
                            <b>Method 1: Adding a decimal place</b><br>
                            If you are just using constants, a decimal place might be a good strategy. To use this strategy,
                            simply add ".0" to the end. Instead of 5 / 2, write
                            <code>5.0 / 2</code>, and it works!
                        </p>
                        <p>
                            <b>Method 2: Typecasting a variable to a float</b><br>
                            If you are using a variable, you need a different strategy. It is not like you can just
                            do <code>var.0</code>! You could make that variable into a <code>float</code>, but if you are just using it for an <code>int</code>,
                            that might over-complicate things. Instead, use <i>typecasting</i>. This is where you add in parentheses
                            the type you want to change it to. For example,</p>

<pre><code>int a = 5;
if (answer == (float)a / 2)</code></pre>
                    </section>
                    <hr>
                    <section id="imprecision">
                        <header>
                            <h2>Floating-point Imprecision</h2>
                        </header>
                        <p>Here is another problem with programming: <i>floating-point imprecision</i>. Let's say you were making
                        a calculator for your students on division for your lesson. This is probably your starting point (again,
                        let's assume you were getting <code>get_float</code> from an external source).</p>
<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    float a = get_float("a: ");
    float b = get_float("b: ");
    printf("Answer: %f\n", a / b);
}
</code></pre>
                    <p>Unlike the quiz, it does seem to work perfectly fine! We use <code>float</code>s to avoid the truncation problem, so everything seems good.
                    When you show that program to the students and performed 1 / 3, however, one student asked, <q>Are you sure 1 / 3 has infinite repeating 3's?</q>
                    <q>Yes, </q> you say. You edit the <code>printf</code> statement to display 10 decimal places like this:</p>
<pre><code>printf("Answer: %.10f\n", a / b);</code></pre>
                    <p>and are confident it will display 0.3333333333, but watch what happens:</p>
<pre><code>$ cc calc.c -o calc
$ ./calc
a: 1
b: 3
Answer: 0.3333333433
</code></pre>
                    <p>Why is the answer 0.33333334? Floating-point imprecision. Remember, the computer works in base-2, or the <i>binary system</i>. 
                    We work in base-10, or the <i>decimal system</i>.
                    When converting binary to decimal, there is a little bit of imprecision. If you ever need more precision, you may use
                    the <code>double</code> type in C to well, <em>double</em> the precision.</p>
<pre><code>double a = get_double("a: ");
double b = get_double("b: ");</code></pre>
                    <p>Now the answer is correctly 0.3333333333.</p>
                    <p>Floating-point imprecision still remains a problem, though. There is still imprecision even with the <code>double</code>
                    type. It is often annoying in the real world, when it displays 1.20000000000001 instead of 1.2 (<code>printf</code> fixes
                    the problem, but never ending decimals still have imprecision). Thus, when comparing two numbers, instead of directly checking
                    for equality, you could have a range of values accounting for floating-point imprecision:</p>
<pre><code>if (a > 0.33 && a < 0.34)
{
    printf("Numbers are the same!\n");
}</code></pre>
                    </section>
                    <hr>
                    <section id="overflow">
                        <header>
                            <h2>Integer Overflow</h2>
                        </header>
                        <p>In your class, you have moved on from division, and are now on to multiplication. You make a 
                        simple program that multiplies two integers together:</p>
<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    int a = get_int("a: ");
    int b = get_int("b: ");
    printf("Answer: %i\n", a * b);
}</code></pre>
                        <p>You give the students a chance to explore the program on their own. One 
                        student comes up to you and says, <q>Why is the answer negative? I typed in two positive numbers.</q>
                        You walk over and see the student's terminal:</p>
<pre><code>$ cc mul.c -o mul
$ ./mul
a: 49353
b: 51678
Answer: -194305179</code></pre>
                        <p>Why is it negative? The answer is because of <i>integer overflow</i>. Integers take up 4 bytes of space.
                        This is 32 bits (<span class="equation">4 * 8</span>). To calculate the amount an integer can go up to, we can use the following equation:</p>
                        <div class="equation">2<sup>32 - 1</sup>- 1</div>
                        <p>The 2 is because it is base-2, or the binary system. We have to subtract one bit to account for the other
                        half to be negative numbers, and subtract another one to account for 0. This expression evaluates to be
                        2,147,483,647. <span class="equation">49353 * 51678</span> evaluates to be 2,550,464,334, more than the amount that can be stored in an
                        integer. As a result, it wraps around to -2,147,483,647 and cuts that extra amount off.</p>
                        <p>To fix this, we can use the <code>long</code> type, or the <code>long long</code> type. These types 
                        use up more memory, so it can go higher.</p>
<pre><code>int main(void)
{
    long a = get_long("a: ");
    long b = get_long("b: ");
    printf("Answer: %li\n", a * b);
}</code></pre>

<pre><code>int main(void)
{
    long long a = get_long_long("a: ");
    long long b = get_long_long("b: ");
    printf("Answer: %lli\n", a * b);
}</code></pre>
                        <p>If you don't care about negative numbers, you may add <code>unsigned</code> to double its range in the positive direction, like this:</p>
<pre><code>int main(void)
{
    unsigned int a = get_unsigned_int("a: ");
    unsigned int b = get_unsigned_int("b: ");
    printf("Answer: %u\n", a * b);
}</code></pre>
                        <p>Here is a table showing the minimum ranges for these data types.</p>
                        <div class="wrapper">
                            <table>
                                <thead>
                                    <tr>
                                        <th>Type</th>
                                        <th>Minimum Range</th>
                                        <th>Typical Range</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>int</code></td>
                                        <td>-32,768 to 32,767</td>
                                        <td>-2,147,483,648 to 2,147,483,647</td>
                                    </tr>
                                    <tr>
                                        <td><code>unsigned int</code></td>
                                        <td>0 to 65,535</td>
                                        <td>0 to 4,294,967,295</td>
                                    </tr>
                                    <tr>
                                        <td><code>long</code></td>
                                        <td>-2,147,483,648 to 2,147,483,647</td>
                                        <td>-9,223,372,036,854,775,807 to 9,223,372,036,854,775,807</td>
                                    </tr>
                                    <tr>
                                        <td><code>unsigned long</code></td>
                                        <td>0 to 4,294,967,295</td>
                                        <td>0 to 18,446,744,073,709,551,615</td>
                                    </tr>
                                    <tr>
                                        <td><code>long long</code></td>
                                        <td class="merge">Almost always -9,223,372,036,854,775,807 to 9,223,372,036,854,775,807</td>
                                        <td></td>
                                    </tr>
                                    <tr>
                                        <td><code>unsigned long long</code></td>
                                        <td class="merge">Almost always 0 to 18,446,744,073,709,551,615</td>
                                        <td></td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </section>
                    <section id="resources">
                        <h2>Resources</h2>
                        <div><a href="https://en.wikipedia.org/wiki/C_data_types">C data types</a></div>
                        <div><a href="https://en.wikipedia.org/wiki/Integer_overflow">Integer Overflow</a></div>
                    </section>
                </main>
                <footer>See all the <a href="examples/">programs</a> used in this article.</footer>
            </div>
        </article>
    </body>
</html>